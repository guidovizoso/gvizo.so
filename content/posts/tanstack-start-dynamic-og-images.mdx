---
title: "Dynamic OG Images with TanStack Start"
summary: "Building dynamic OG images in TanStack Start. Inspired by vercel/og, powered by Takumi."
publishedAt: "2025-10-12"
---

# Dynamic OG Images with TanStack Start

I love the **TanStack ecosystem**, and especially **TanStack Start** â€” itâ€™s modern, fast, and feels like the natural evolution of React routing.  
But thereâ€™s one thing we missed from the Next.js and Vercel world: the sheer convenience of **dynamic OG images**.

Those little preview cards you see when sharing links on social media arenâ€™t just pretty â€” theyâ€™re *tiny brand ambassadors*. They extend your siteâ€™s personality outside the browser, and when done right, they look *amazing*.

So we decided to bring that experience to TanStack Start â€” **a-la `vercel/og`**, but with our own flavor.

---

## Act I: The Stack

Our toolkit for this adventure:

- ðŸ§­ **TanStack Start** â€” for server routes and the overall framework  
- âš¡ **Takumi** â€” a Rust-based alternative to Satori (the engine behind `vercel/og`), offering incredible performance and WebAssembly support  

Together, they let us generate beautiful, dynamic images right from the server â€” no Node canvas, no complex setups.

---

## Act II: The Plan

The idea was simple:

> Use a TanStack Start server route to dynamically generate images, passing in any metadata (like title or author) through query parameters.

Every time a page is shared, that route renders a fresh OG image â€” on the fly.

---

## Act III: Installing Takumi

First, we added Takumi to our project:

```bash
bun add @takumi-rs/core @takumi-rs/helpers @takumi-rs/image-response
```

Thatâ€™s all you need.  
Takumiâ€™s core, helpers, and the `image-response` package handle everything â€” from JSX rendering to generating the final image buffer.

> âš ï¸ **Important**:
> If you're planning on deploying this to Vercel, you need to add the following to your `vite.config.ts`:

```ts
nitro: {
    preset: "vercel",
    externals: {
      traceInclude: [
        "node_modules/@takumi-rs/core",
        "node_modules/@takumi-rs/image-response",
        "node_modules/@takumi-rs/helpers",
        "node_modules/@takumi-rs/core-linux-x64-gnu",
        "node_modules/@takumi-rs/core-linux-arm64-gnu",
        "node_modules/@takumi-rs/core-darwin-arm64",
        "node_modules/@takumi-rs/core-darwin-x64",
      ],
    },
  },
```

This will tell Nitro to include the necessary files in the output and Vercel's function will find the appropriate binary for the platform.

---

## Act IV: Setting Up the Route

Inside our TanStack Start project, we created a new **server route** at  
`src/routes/api/og.tsx`.

```tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/og")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        // We'll handle the image generation here
      },
    },
  },
});
```

This gives us a dedicated endpoint â€” `/api/og` â€” that we can hit with query parameters like `?title=My+Post&author=Guido`.

---

## Act V: The OG Component

Next, we defined a simple JSX component to represent the OG layout.  
This component will be rendered by Takumi when generating the image:

```tsx
function OgImage({
  title = "Your amazing website.",
  author = "Your name",
}: {
  title: string;
  author: string;
}) {
  return (
    <div
      style={{
        backgroundColor: "#ffffff",
        width: "100%",
        height: "100%",
        padding: "5% 10%",
        display: "flex",
        flexDirection: "column",
      }}
    >
      <p
        style={{
          color: "#000000",
          fontSize: "60px",
          fontWeight: "normal",
          paddingTop: "3%",
        }}
      >
        {title}
      </p>
      <div style={{ marginTop: "auto" }}>
        <p
          style={{
            color: "#000000",
            fontSize: "30px",
            fontWeight: "bold",
            marginLeft: "auto",
          }}
        >
          {author}
        </p>
      </div>
    </div>
  );
}
```

Itâ€™s minimal, readable, and fully customizable â€” you can later replace inline styles with your design system or Tailwind CSS-in-JSX utilities.

---

## Act VI: Putting It All Together

Now, letâ€™s hook the component into the route and generate the actual image.

Weâ€™ll dynamically import Takumiâ€™s `ImageResponse` inside our route to avoid bundling it into the client.

```tsx
export const Route = createFileRoute("/og")({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const { ImageResponse } = await import("@takumi-rs/image-response");

        const url = new URL(request.url);
        const title = url.searchParams.get("title");
        const author = url.searchParams.get("author");

        return new ImageResponse(<OgImage title={title} author={author} />, {
          width: 1200,
          height: 630,
        });
      },
    },
  },
});
```

Thatâ€™s it â€” you now have a fully dynamic OG image generator.  
Hit `/og?title=Hello%20World&author=Guido` and watch it render.

---

## Act VII: Integrating with Your Head Tags

To make it useful for SEO and social sharing, you can include your new OG route inside your TanStack Start root head.

```tsx
// src/routes/__root.tsx

export const Route = createRootRouteWithContext<RouterAppContext>()({
  head: () => ({
    meta: [
      // ... other meta tags
      {
        name: "og:image",
        content: "YOUR_URL/og?title=YOUR_TITLE&author=YOUR_AUTHOR",
      },
    ],
  }),
  component: RootDocument,
});
```

Now, every page you share on Twitter, LinkedIn, or Slack will generate a beautiful, dynamic image in real time.

---

## Act VIII: Beyond the Basics

This pattern scales beautifully:

- You can generate **unique images per blog post** by setting the `og:image` tag dynamically in each route.
- You can pull data from your CMS or filesystem.
- You can even render SVGs, logos, or gradients â€” all using JSX.

And because itâ€™s Rust-powered via Takumi, you get blazing-fast image generation with minimal overhead.

---

## Epilogue

With just a few lines of code, we brought **vercel/og-style dynamic image generation** to **TanStack Start** â€” with full type safety and performance to match.

Itâ€™s another example of how flexible the TanStack ecosystem is â€” you donâ€™t need Next.js to get powerful, modern capabilities.

Dynamic, fast, and built the TanStack way.  
Thatâ€™s the kind of magic we like.
