---
title: "Dynamic OG Images with TanStack Start"
summary: "Creating dynamic OG images with TanStack Start a-la vercel/og."
publishedAt: "2025-10-12"
---

# Dynamic OG Images with TanStack Start

When we started building our product, we knew one thing for sure: we didn't want to play the guessing game between backend and frontend.

I usually TypeScript all the things, but this time we decided to build a FastAPI backend. That left us out of luck when it came to using TRPC for typing our API.

But here's the thing: type safety isn't something you should compromise on.

You know the drill: wondering if that endpoint is `/v1/customers` or `/api/customers`? Trying to remember if that field is called `name` or `full_name`? Manually maintaining TypeScript types for backend responses?

Instead of bolting on type safety later, we designed our stack around it from day one.

---

## Act I: FastAPI as the Single Source of Truth

We chose FastAPI for our backend because it naturally encourages clean, explicit definitions. Every endpoint describes itself through Python type hints and Pydantic models. That means our API documentation and data validation come for free, and so does the OpenAPI spec.

By default, FastAPI generates a live OpenAPI schema at `/openapi.json`. That's not just a nice bonus: it's an always-up-to-date contract for your entire system.

We exposed it when running dev at `http://localhost:8000/openapi.json` so our frontend could consume it directly during local development.

---

## Act II: Auto-Generated Types with `openapi-ts`

From the start, we wanted **the backend to define the truth** and **the frontend to just import it**.

Enter [`openapi-ts`](https://openapi-ts.dev/cli). With a single command, it takes that live FastAPI spec and transforms it into strongly typed TypeScript definitions.

Here's how we set it up step by step:

**1. Install `openapi-ts`**

```bash
bun add openapi-typescript
```

**2. Create a script to generate the types in your frontend's `package.json`**

```json filename="package.json"
"scripts": {
  "generate-types": "openapi-typescript http://localhost:8000/openapi.json -o src/types/api-schema.ts"
}
```

Now every time you run `bun generate-types`, fresh types get generated in `src/types/api-schema.ts` and are ready to use.

This generates not just the endpoint routes but also the request and response types for each endpoint. This makes it super easy to abstract the responses into types you can use throughout your application.

```typescript filename=src/types/api-schema.ts
import type { components } from "./api-schema";

export type User = components["schemas"]["UserSchema"];
```

Done.

---

## Act III: Type-Safe Calls with openapi-fetch

The next piece of the puzzle was actually using those types to make requests. We didn't want just another generic fetch wrapper: we wanted something that knew what endpoints existed, what data they expected, and what they returned. So we went back to the openapi-ts ecosystem and found [`openapi-fetch`](https://openapi-ts.dev/openapi-fetch/), which was made exactly for this.

A simple wrapper and we were ready to go:

```typescript
import createClient from "openapi-fetch";
import { getConfig } from "@/config";
import type { paths } from "@/types/api-schema"; // generated by openapi-typescript

const config = getConfig();

export const apiClient = createClient<paths>({
  baseUrl: config.apiUrl,
  credentials: "include",
});
```

Instant autocomplete. Compile-time validation. No runtime surprises.

If someone changes a parameter or removes a field in the backend, the next frontend build fails loudly, exactly how we like it.

---

## Act IV: The Developer Loop That Feels Effortless

Here's what development looks like now:

**Define a new route in FastAPI**: add your path, input, and output models.

**Run the backend**: FastAPI automatically regenerates `/openapi.json`.

**Regenerate the frontend types:**

```bash
bun run generate-types
```

**Use it with openapi-fetch**: fully typed requests, right in your code editor.

That's it. No manual syncs. No shared constants file. No "wait, who changed this?" Slack messages. It's a tiny workflow that scales beautifully.

---

## Summary: The Stack That Talks to Itself

**FastAPI**: defines endpoints and auto-generates OpenAPI

**openapi-ts**: turns that schema into TypeScript types

**openapi-fetch**: makes fully typed API calls

Together, they create a developer experience that feels almost magical: everything stays in sync, automatically, all the time.
